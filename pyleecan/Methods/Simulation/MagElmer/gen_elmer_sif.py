# -*- coding: utf-8 -*-
import numpy as np

from numpy import pi, floor_divide, sign, angle as np_angle
from os.path import join

from ....Functions.labels import (
    AIRGAP_LAB,
    ROTOR_LAB_S,
    short_label,
    decode_label,
    get_obj_from_label,
    LAM_LAB_S,
    STATOR_LAB_S,
    HOLEV_LAB_S,
    HOLEM_LAB_S,
    WIND_LAB_S,
    MAG_LAB,
    SHAFT_LAB,
    SLID_LAB,
)
from ....Functions.Winding.find_wind_phase_color import get_phase_id
from .... import __version__

from ....Classes.MachineSIPMSM import MachineSIPMSM
from ....Classes.MachineIPMSM import MachineIPMSM
from ....Methods import NotImplementedYetError

from ....Classes.Section import Section
from ....Classes.SolverInputFile import SolverInputFile
from ....Methods.Elmer.Section import File, Variable, MATC

# some constants
ROTOR_SLIDING_BAND_LABEL = ROTOR_LAB_S + "-0_" + SLID_LAB
ROTOR_AIRGAP_LABEL = ROTOR_LAB_S + "-0_" + AIRGAP_LAB
DEFAULT_EQUATION = 1
DEFAULT_MATERIAL = 1  # Air


def gen_elmer_sif(self, output, sym, time, angle_rotor, Is, Ir):
    """
    Generate the Elmer solver input file (sif).

    Parameters
    ----------
    self: MagElmer
        A MagElmer object
    output: Output
        An Output object
    sym: int
        Spatial symmetry factor
    time: ndarray
        Time vector for calculation
    Is : ndarray
        Stator current matrix (qs,Nt) [A]
    Ir : ndarray
        Stator current matrix (qs,Nt) [A]
    angle_rotor: ndarray
        Rotor angular position vector (Nt,)

    Return
    ------
    elmer_sif_file: str
        Full file name of the generated Elmer solver file
    """

    project_name = self.get_path_save_fea(output)
    mesh_names_file = join(project_name, "mesh.names")
    boundaries = {}
    bodies = {}
    machine = output.simu.machine
    BHs = output.geo.stator.BH_curve  # Stator B(H) curve
    BHr = output.geo.rotor.BH_curve  # Rotor B(H) curve
    # Is = output.elec.Is  # Stator currents waveforms
    # Ir = output.elec.Ir  # Rotor currents waveforms
    Speed = output.elec.OP.get_N0()
    rotor_mat_file = "rotor_material.pmf"
    stator_mat_file = "stator_material.pmf"
    rotor_mat_fullfile = join(project_name, rotor_mat_file)
    stator_mat_fullfile = join(project_name, stator_mat_file)

    # TODO: Time vector must be greater than one
    time = np.append(time, time[1] + time[-1])
    formatter = {"float_kind": lambda x: "%.2e" % x}
    timesize_str = np.array2string(np.diff(time), separator=" ", formatter=formatter)

    timelen = len(time) - 1
    formatter = {"int": lambda x: "%d" % x}
    ones_str = np.array2string(np.ones(timelen), separator=" ", formatter=formatter)
    timeinterval_str = ones_str.replace(".", "")

    # get boundaries and bodies from mesh files
    with open(mesh_names_file, "rt") as f:
        for line in f:
            fields = line.strip().split()
            if fields[0] == "$":
                field_name = fields[1]
                field_value = fields[3]
                # update dictionary
                # _settings['Geometry'][field_name] = field_value
                if "BOUNDARY" in field_name:
                    boundaries[field_name] = field_value
                else:
                    bodies[field_name] = {
                        "id": field_value,
                        "mat": DEFAULT_MATERIAL,  # air by Default
                        "eq": DEFAULT_EQUATION,
                        "bf": None,
                        "tg": None,
                    }

    ### generate rotor material file ###
    with open(rotor_mat_fullfile, "wt") as ro:
        ro.write("! File Generated by pyleecan v{0}\n".format(__version__))
        ro.write("! Material Name: {0}\n".format(machine.rotor.mat_type.name))
        ro.write("! B-H Curve Rotor Material\n")
        ro.write("Electric Conductivity = 0\n")
        ro.write("H-B Curve = Variable coupled iter\n")
        ro.write("\tReal\t\tCubic Monotone\n")
        for ii in range(BHr.shape[0]):
            ro.write("\t\t{0}\t\t{1}\n".format(BHr[ii][1], BHr[ii][0]))
        ro.write("End\n")

    ### generate stator material file ###
    with open(stator_mat_fullfile, "wt") as ro:
        ro.write("! File Generated by pyleecan v{0}\n".format(__version__))
        ro.write("! Material Name: {0}\n".format(machine.stator.mat_type.name))
        ro.write("! B-H Curve Stator Material\n")
        ro.write("Electric Conductivity = 0\n")
        ro.write("H-B Curve = Variable coupled iter\n")
        ro.write("\tReal\t\tCubic Monotone\n")
        for ii in range(BHs.shape[0]):
            ro.write("\t\t{0}\t\t{1}\n".format(BHs[ii][1], BHs[ii][0]))
        ro.write("End\n")

    ### prepare sif generation###
    elmer_sif_file = join(project_name, "pyleecan_elmer.sif")
    pp = machine.stator.winding.p
    wind_mat = machine.stator.winding.get_connection_mat(machine.stator.slot.Zs)
    surf_wind = machine.stator.slot.comp_surface_active()
    ror = machine.rotor.comp_radius_mec()
    sir = machine.stator.comp_radius_mec()

    if isinstance(machine, MachineSIPMSM):
        # magnet_0 = machine.rotor.slot.magnet[0]
        magnet_0 = machine.rotor.magnet
    elif isinstance(machine, MachineIPMSM):
        magnet_dict = machine.rotor.hole[0].get_magnet_dict()
        magnet_0 = magnet_dict["magnet_0"]
    else:
        self.get_logger().info("ElmerSolver [Error]: Unsupported Machine Geometry")
        return False

    surf_list = machine.build_geometry(sym=sym)
    pm_index = 6
    Mangle = list()

    # initialize Body Force LUT for required current densities TODO: only stator for now
    qs = machine.stator.winding.qs
    bf_id = 2  # first Body Force is used for rotation (i.e. Rigid Mesh Mapper)
    bf_LUT = dict()
    for ii in range(qs):
        bf_LUT[ii] = dict()

    # evaluate surfaces
    for surf in surf_list:
        label = short_label(surf.label)
        label_dict = decode_label(label)
        point_ref = surf.point_ref

        # check if surface is in Elmer model
        if not bodies.get(label, None):
            self.get_logger().warning(
                f"{label}: Surface is not in Elmer model. Skipping surface."
            )
            continue  # skip this surface

        # hole magnets
        if HOLEM_LAB_S in label_dict["surf_type"]:
            mag_obj = get_obj_from_label(machine, label_dict=label_dict)
            if mag_obj.type_magnetization == 1:  # Parallel
                magnetization_type = "parallel"
                # calculate pole angle and angle of pole middle
                T_id = label_dict["T_id"]
                hole = mag_obj.parent
                Zh = hole.Zh
                alpha_p = 360 / Zh
                ref_ang = np_angle(point_ref, deg=True)
                mag_0 = (floor_divide(ref_ang, alpha_p) + 0.5) * alpha_p

                mag_dict = hole.comp_magnetization_dict()
                mag = mag_0 + mag_dict["magnet_" + str(T_id)] * 180 / pi
                # modifiy magnetisation of south poles
                if (label_dict["S_id"] % 2) == 1:
                    mag = mag + 180
            else:
                raise NotImplementedYetError(
                    "Only parallele magnetization are available for HoleMagnet"
                )

            Mangle.append(mag)
            bodies[label]["mat"] = pm_index
            bodies[label]["bf"] = 1
            bodies[label]["tg"] = 1
            pm_index += 1

        # surface magents
        elif MAG_LAB in label_dict["surf_type"]:
            mag_obj = get_obj_from_label(machine, label_dict=label_dict)
            if mag_obj.type_magnetization == 0 and (label_dict["S_id"] % 2) == 0:
                mag = 0  # North pole magnet
                magnetization_type = "radial"
            elif mag_obj.type_magnetization == 0:
                mag = 180  # South pole magnet
                magnetization_type = "radial"
            elif mag_obj.type_magnetization == 1 and (label_dict["S_id"] % 2) == 0:
                mag = np_angle(point_ref) * 180 / pi  # North pole magnet
                magnetization_type = "parallel"
            elif mag_obj.type_magnetization == 1:
                mag = np_angle(point_ref) * 180 / pi + 180  # South pole magnet
                magnetization_type = "parallel"
            elif mag_obj.type_magnetization == 2:
                Zs = mag_obj.parent.slot.Zs
                mag = str(-(Zs / 2 - 1)) + " * theta + 90 "
                magnetization_type = "hallback"
            else:
                raise NotImplementedYetError("Magnetization type not implemented yet.")

            Mangle.append(mag)
            bodies[label]["mat"] = pm_index
            bodies[label]["bf"] = 1
            bodies[label]["tg"] = 1
            pm_index += 1

        # windings
        elif WIND_LAB_S in label_dict["surf_type"]:
            phase_id, Ncond = _get_wind_props(machine, label)
            bodies[label]["mat"] = 5
            # reuse a Body Force if the phase and the number of conductors is the same
            if Ncond not in bf_LUT[phase_id]:
                bf_LUT[phase_id][Ncond] = bf_id
                bodies[label]["bf"] = bf_id
                bf_id += 1
            else:
                bodies[label]["bf"] = bf_LUT[phase_id][Ncond]
            bodies[label]["winding"] = True

        # rotor lamination
        elif (
            LAM_LAB_S in label_dict["surf_type"]
            and ROTOR_LAB_S in label_dict["lam_label"]
        ):
            bodies[label]["mat"] = 4
            bodies[label]["bf"] = 1
            bodies[label]["tg"] = 1

        # stator lamination
        elif (
            LAM_LAB_S in label_dict["surf_type"]
            and STATOR_LAB_S in label_dict["lam_label"]
        ):
            bodies[label]["mat"] = 3

        # shaft
        elif SHAFT_LAB in label_dict["surf_type"]:
            bodies[label]["mat"] = 1
            bodies[label]["bf"] = 1
            bodies[label]["tg"] = 1

        # ventilation hole
        elif HOLEV_LAB_S in label_dict["surf_type"]:
            bodies[label]["mat"] = 1
            bodies[label]["bf"] = 1
            bodies[label]["tg"] = 1

        # surface type is not implemented yet
        else:
            self.get_logger().warning(
                f"{label}: Surface type is not implemnted yet. "
                + "Setting default body properties"
            )

    # The following bodies are not in the surf_list (see above)
    bodies[ROTOR_AIRGAP_LABEL]["bf"] = 1
    bodies[ROTOR_SLIDING_BAND_LABEL]["bf"] = 1

    # get magnet parameter # TODO use magnet temperature
    No_Magnets = pm_index - 6
    magnet_temp = self.T_mag
    Hcm20 = magnet_0.mat_type.mag.get_Hc()
    Br = magnet_0.mat_type.mag.get_Brm(T_op=self.T_mag)
    magnet_permeability = magnet_0.mat_type.mag.mur_lin
    conductivity_m = magnet_0.mat_type.elec.get_conductivity(
        T_op=magnet_temp, T_ref=20.0
    )

    # winding parameter
    winding_temp = 20.0  # Fixed for Now
    cond_mat = machine.stator.winding.conductor.cond_mat
    conductivity = cond_mat.elec.get_conductivity(T_op=winding_temp, T_ref=20)
    Ncond = 1  # Fixed for Now
    Cp = 1  # Fixed for Now
    qs = len(machine.stator.get_name_phase())

    # misc. parameter
    skip_steps = 1  # Fixed for now
    degrees_step = 1  # Fixed for now
    current_angle = 0 - pp * degrees_step * skip_steps
    angle_shift = self.angle_rotor_shift - self.angle_stator_shift
    rotor_init_pos = machine.comp_angle_rotor_initial() + angle_shift
    rotor_d_axis = machine.rotor.comp_angle_d_axis() * 180.0 / pi

    ##########################
    ### generate sif file  ###

    with open(elmer_sif_file, "wt") as fo:
        # variables section
        fo.write("! File Generated by pyleecan v{0}\n".format(__version__))
        fo.write("$ WM = 2*pi*{0}/60  ! Mechanical Frequency [rad/s]\n".format(Speed))
        fo.write("$ PP = {0} ! Pole pairs\n".format(pp))
        fo.write("$ WE = PP*WM  ! Electrical Frequency [Hz]\n")
        fo.write("$ H_PM = {0}  ! Magnetization at 20 deg C [A/m]\n".format(round(Hcm20, 2)))  # fmt: skip
        fo.write("$ Shift = 2*pi/{0}  ! N-phase machine [rad]\n".format(qs))
        fo.write("$ Gamma = {0}*pi/180  ! Current Angle [rad]\n".format(round(current_angle, 2)))  # fmt: skip
        fo.write("$ Ncond = {0}  ! Conductors per coil\n".format(Ncond))
        fo.write("$ Cp = {0}  ! Parallel paths\n".format(Cp))
        fo.write("$ Is = {0}  ! Stator current [A]\n".format(0.0))
        fo.write("$ Aaxis = {0}  ! Axis Coil A [deg]\n".format(0.0))
        fo.write("$ Carea = {0}  ! Coil Side Conductor Area [m2]\n".format(surf_wind))

        for mm in range(1, No_Magnets + 1):
            fo.write("$ Mangle{0} = {1}  ! Magnetization Angle [deg]\n".format(mm, round(Mangle[mm - 1], 2)))  # fmt: skip

        fo.write("$ Nsteps = {0}            !\n".format(2))
        fo.write("$ StepDegrees = {0}       !\n".format(degrees_step))
        fo.write("$ DegreesPerSec = WM*180.0/pi  !\n")
        fo.write("$ RotorInitPos = {}!\n".format(round(rotor_init_pos * 180.0 / pi, 2)))

        # header section
        fo.write("\nHeader\n")
        fo.write("\tCHECK KEYWORDS Warn\n")
        fo.write('\tMesh DB "."\n')
        fo.write('\tInclude Path "."\n')
        fo.write('\tResults Directory "."\n')
        fo.write("End\n")

        # constants section
        fo.write("\nConstants\n" "\tPermittivity of Vacuum = 8.8542e-12\n" "End\n")

        # Simulation Section
        fo.write("\nSimulation\n")
        fo.write("\tMax Output Level = 4\n")
        fo.write("\tCoordinate System = Cartesian 2D\n")
        fo.write("\tCoordinate Scaling = {0}\n".format(1.0))
        fo.write("\tSimulation Type = Transient\n")
        fo.write("\tTimestepping Method = BDF\n")
        fo.write("\tBDF Order = 2\n")
        # fo.write("\tTimestep Sizes = $ (StepDegrees / DegreesPerSec)  ! sampling time\n")
        # fo.write("\tTimestep Intervals = $ Nsteps              ! steps\n")
        # fo.write("\tOutput Intervals = 1\n")
        fo.write("\tTimestep Sizes({0}) = {1}\n".format(timelen, timesize_str[1:-1]))  # fmt: skip
        fo.write("\tTimestep Intervals({0}) = {1}\n".format(timelen, timeinterval_str[1:-1]))  # fmt: skip
        fo.write("\tUse Mesh Names = Logical True\n")
        fo.write("End\n")

        # Materials Section
        fo.write("\n!--- MATERIALS ---\n")

        fo.write("Material 1\n")
        fo.write('\tName = "Air"\n')
        fo.write("\tRelative Permeability = 1\n")
        fo.write("\tElectric Conductivity = 0\n")
        fo.write("End\n")

        fo.write("\nMaterial 2\n")
        fo.write('\tName = "Insulation"\n')
        fo.write("\tRelative Permeability = 1\n")
        fo.write("\tElectric Conductivity = 0\n")
        fo.write("End\n")

        fo.write("\nMaterial 3\n")
        fo.write('\tName = "StatorMaterial"\n')
        fo.write('\tInclude "{0}"\n'.format(stator_mat_file))
        fo.write("End\n")

        fo.write("\nMaterial 4\n")
        fo.write('\tName = "RotorMaterial"\n')
        fo.write('\tInclude "{0}"\n'.format(rotor_mat_file))
        fo.write("End\n")

        fo.write("\nMaterial 5\n")
        fo.write('\tName = "Copper"\n')
        fo.write("\tRelative Permeability = 1\n")
        fo.write("\tElectric Conductivity = {0}\n".format(round(conductivity, 2)))
        fo.write("End\n")

        magnets_per_pole = No_Magnets  # TODO: Assumes only one pole drawn
        for m in range(1, magnets_per_pole + 1):
            mat_number = 5 + m
            N = int((m - 1) / magnets_per_pole)
            if magnetization_type == "parallel":
                fo.write("\nMaterial {0}\n".format(mat_number))
                fo.write('\tName = "PM_{0}"\n'.format(m))
                fo.write("\tRelative Permeability = {0}\n".format(magnet_permeability))
                fo.write("\tMagnetization 1 = Variable time, timestep size\n")
                fo.write('\t\tReal MATC  "H_PM*cos(WM*(tx(0)-tx(1)) + {0}*pi/PP + {0}*pi + (RotorInitPos + Mangle{1})*pi/180)"\n'.format(N, m))  # fmt: skip
                fo.write("\tMagnetization 2 = Variable time, timestep size\n")
                fo.write('\t\tReal MATC "H_PM*sin(WM*(tx(0)-tx(1)) + {0}*pi/PP + {0}*pi + (RotorInitPos + Mangle{1})*pi/180)"\n'.format(N, m))  # fmt: skip
                fo.write("\tElectric Conductivity = {0}\n".format(round(conductivity_m, 2)))  # fmt: skip
                fo.write("End\n")

            elif magnetization_type == "radial":
                fo.write("\nMaterial {0}\n".format(mat_number))
                fo.write('\tName = "PM_{0}"\n'.format(m))
                fo.write("\tRelative Permeability = {0}\n".format(magnet_permeability))
                fo.write("\tMagnetization 1 = Variable Coordinate\n")
                fo.write('\t\tReal MATC  "H_PM*cos(atan2(tx(1),tx(0)) + {0}*pi + Mangle{1}*pi/180)"\n'.format(m - 1, m))  # fmt: skip
                fo.write("\tMagnetization 2 = Variable Coordinate\n")
                fo.write('\t\tReal MATC "H_PM*sin(atan2(tx(1),tx(0)) + {0}*pi + Mangle{1}*pi/180)"\n'.format(m - 1, m))  # fmt: skip
                fo.write("\tElectric Conductivity = {0}\n".format(round(conductivity_m, 2)))  # fmt: skip
                fo.write("End\n")

            elif magnetization_type == "perpendicular":
                fo.write("\nMaterial {0}\n".format(mat_number))
                fo.write('\tName = "PM_{0}"\n'.format(m))
                fo.write("\tRelative Permeability = {0}\n".format(magnet_permeability))
                fo.write("\tMagnetization 1 = Variable time, timestep size\n")
                fo.write('\t\tReal MATC  "H_PM*cos(WM*(tx(0)-tx(1)) + {0}*pi/PP + {0}*pi + Aaxis*pi/180 + (Mangle{1}*pi/180))"\n'.format(N, m))  # fmt: skip
                fo.write("\tMagnetization 2 = Variable time, timestep size\n")
                fo.write('\t\tReal MATC "H_PM*sin(WM*(tx(0)-tx(1)) + {0}*pi/PP + {0}*pi + Aaxis*pi/180 + (Mangle{1}*pi/180))"\n'.format(N, m))  # fmt: skip
                fo.write("\tElectric Conductivity = {0}\n".format(round(conductivity_m, 2)))  # fmt: skip
                fo.write("End\n")

            else:
                fo.write("\nMaterial {0}\n".format(mat_number))
                fo.write('\tName = "PM_{0}"\n'.format(m))
                fo.write("\tRelative Permeability = {0}\n".format(magnet_permeability))
                fo.write("\tElectric Conductivity = {0}\n".format(round(conductivity_m, 2)))  # fmt: skip
                fo.write("End\n")

        # Body Forces Section
        fo.write("\n!--- BODY FORCES ---\n")

        fo.write("Body Force 1\n")
        fo.write('\tName = "BodyForce_Rotation"\n')
        fo.write("\tMesh Rotate 3 = Variable time\n")
        fo.write("\t\tReal\n")
        fo.write("\t\t0.0\t\t0.0\n")
        for tt in range(1, timelen + 1):
            ang_rot_deg = angle_rotor[tt - 1] * 180.0 / pi
            fo.write("\t\t{:.2e}\t\t{:.3f}\n".format(time[tt], ang_rot_deg))
        fo.write("\tEnd\n" "End\n")

        # current density Body Forces
        for phase_id, Ncond_dict in bf_LUT.items():
            for Ncond, ii in Ncond_dict.items():
                fo.write(f"Body Force {ii}\n")
                fo.write(f'\tName = "Phase_{phase_id}_BF_{ii}"\n')
                fo.write("\tCurrent Density = Variable time\n")
                fo.write("\t\tReal\n")
                fo.write("\t\t0.0\t\t0.0\n")
                for tt in range(1, timelen + 1):
                    J = Ncond * Is[phase_id, tt - 1] / surf_wind
                    fo.write("\t\t{:.2e}\t\t{:.3f}\n".format(time[tt], J))
                fo.write("\tEnd\n" "End\n")

        # Bodies Section
        fo.write("\n!--- BODIES ---\n")
        for label, body in bodies.items():
            bid = body["id"]
            beq = body["eq"]
            bmat = body["mat"]
            bf = body["bf"]
            btg = body["tg"]

            fo.write("Body {0}\n".format(bid))
            fo.write("\tName = {0}\n".format(label))
            fo.write("\tEquation = {0}\n".format(beq))
            fo.write("\tMaterial = {0}\n".format(bmat))

            if bf is not None:
                fo.write("\tBody Force = {0}\n".format(bf))
            if btg is not None:
                fo.write("\tTorque Groups = Integer {0}\n".format(btg))
            if label == ROTOR_SLIDING_BAND_LABEL:
                fo.write("\tR Inner = Real {0}\n" "\tR Outer = Real {1}\n".format(ror, sir))  # fmt: skip
            if body.get("winding", False):
                fo.write("\t{0} = Logical True\n".format(label))

            fo.write("End\n\n")

        # Equation Section
        fo.write("Equation 1\n")
        fo.write('\tName = "Model_Domain"\n')
        fo.write("\tActive Solvers(6) = 1 2 3 4 5 6\n")
        fo.write("End\n")

        # Solver Section
        fo.write("\n!--- SOLVERS ---\n")
        fo.write("Solver 1\n")
        fo.write("\tExec Solver = Before Timestep\n")
        fo.write("\tEquation = MeshDeform\n")
        fo.write('\tProcedure = "RigidMeshMapper" "RigidMeshMapper"\n')
        fo.write("End\n")

        fo.write("\nSolver 2\n")
        fo.write("\tEquation = MgDyn2D\n")
        fo.write('\tProcedure = "MagnetoDynamics2D" "MagnetoDynamics2D"\n')
        fo.write("\tExec Solver = Always\n")
        fo.write("\tVariable = A\n")

        fo.write("\tNonlinear System Convergence Tolerance = {0}\n".format(1e-7))
        fo.write("\tNonlinear System Max Iterations = {0}\n".format(100))
        fo.write("\tNonlinear System Min Iterations = {0}\n".format(1))
        fo.write("\tNonlinear System Newton After Iterations = {0}\n".format(5))
        fo.write("\tNonlinear System Relaxation Factor = {0}\n".format(0.9))
        fo.write("\tNonlinear System Convergence Without Constraints = {0}\n".format("Logical True"))  # fmt: skip
        fo.write("\tExport Lagrange Multiplier = {0}\n".format("Logical True"))
        fo.write("\tLinear System Abort Not Converged = {0}\n".format("Logical False"))
        fo.write("\tLinear System Solver = {0}\n".format("Direct"))
        fo.write("\tLinear System Direct Method = {0}\n".format("umfpack"))
        fo.write("\tOptimize Bandwidth = {0}\n".format("Logical True"))
        fo.write("\tLinear System Preconditioning =  {0}\n".format("ILU2"))
        fo.write("\tLinear System Max Iterations =  {0}\n".format(5000))
        fo.write("\tLinear System Residual Output =  {0}\n".format(20))
        fo.write("\tLinear System Convergence Tolerance =  {0}\n".format(1e-9))
        fo.write("\tMortar BCs Additive =  {0}\n".format("Logical True"))
        fo.write("End\n")

        fo.write("\nSolver 3\n")
        fo.write("\tExec Solver = Always\n")
        fo.write("\tEquation = CalcFields\n")
        fo.write('\tPotential Variable = "A"\n')
        fo.write('\tProcedure = "MagnetoDynamics" "MagnetoDynamicsCalcFields"\n')
        fo.write("\tCalculate Nodal Forces = Logical True\n")
        fo.write("\tCalculate Magnetic Vector Potential = Logical True\n")
        fo.write("\tCalculate Winding Voltage = Logical True\n")
        fo.write("\tCalculate Current Density = Logical True\n")
        fo.write("\tCalculate Maxwell Stress = Logical True\n")
        fo.write("\tCalculate JxB = Logical True\n")
        fo.write("\tCalculate Magnetic Field Strength = Logical True\n")
        fo.write("\t! Enforcing fields to be continuous is a little problematic for discontious fields\n")  # fmt: skip
        fo.write("\tCalculate Nodal Fields = {0}\n".format("Logical False"))
        fo.write("\tCalculate Elemental Fields = {0}\n".format("Logical True"))
        fo.write("End\n")

        fo.write("\nSolver 4\n")
        fo.write("\tExec Solver = After Timestep\n")
        fo.write('\tProcedure = "ResultOutputSolve" "ResultOutputSolver"\n')
        fo.write('\tOutput File Name = "{0}"\n'.format("step"))
        fo.write("\tVtu Format = True\n")
        fo.write(
            "\tBinary Output = False\n"
        )  # there are issues with Elmer binary sometimes
        fo.write("\tSingle Precision = True\n")
        fo.write("\tSave Geometry Ids = True\n")
        fo.write("\tShow Variables = True\n")
        fo.write("End\n")

        fo.write("\nSolver 5\n")
        fo.write("\tExec Solver = After Timestep\n")
        fo.write("\tEquation = SaveLine\n")
        fo.write('\tFilename = "{0}"\n'.format("lines.dat"))
        fo.write('\tProcedure = "SaveData" "SaveLine"\n')
        # fo.write("\tVariable 1 = Magnetic Flux Density 1\n")
        # fo.write("\tVariable 2 = Magnetic Flux Density 2\n")
        # fo.write("\tVariable 3 = Magnetic Flux Density 3\n")
        fo.write("\tVariable 1 = Magnetic Flux Density e 1\n")
        fo.write("\tVariable 2 = Magnetic Flux Density e 2\n")
        fo.write("\tVariable 3 = Magnetic Flux Density e 3\n")
        fo.write("End\n")

        fo.write("\nSolver 6\n")
        fo.write("\tExec Solver = After Timestep\n")
        fo.write('\tFilename = "{0}"\n'.format("scalars.dat"))
        fo.write('\tProcedure = "SaveData" "SaveScalars"\n')
        fo.write("\tShow Norm Index = 1\n")
        var_id = 1
        for label, body in bodies.items():
            if body.get("winding", False):
                fo.write("\tVariable {0} = A\n".format(var_id))
                fo.write("\tOperator {0} = body int\n".format(var_id))
                fo.write("\tMask Name {0} = {1}\n".format(var_id, label))
                var_id += 1
        fo.write("End\n")

        # Boundaries Section
        fo.write("\n!--- BOUNDARIES ---\n")
        for k, v in boundaries.items():
            if k == "VP0_BOUNDARY":
                fo.write("Boundary Condition {0}\n".format(v))
                fo.write("\tName = {0}\n".format(k))
                fo.write("\tA = Real 0\n")
                fo.write("End\n\n")
            elif k == "MASTER_STATOR_BOUNDARY":
                for k1, v1 in boundaries.items():
                    if k1 == "SLAVE_STATOR_BOUNDARY":
                        slave = v1
                        break
                if not self.is_periodicity_a:
                    fo.write("Boundary Condition {0}\n".format(v))
                    fo.write("\tName = {0}\n".format(k))
                    fo.write("\tMortar BC = Integer {0}\n".format(slave))
                    fo.write("\tMortar BC Static = Logical True\n")
                    fo.write("\tRadial Projector = Logical True\n")
                    fo.write("\tGalerkin Projector = Logical True\n")
                    fo.write("End\n\n")
                else:
                    fo.write("Boundary Condition {0}\n".format(v))
                    fo.write("\tName = {0}\n".format(k))
                    fo.write("\tMortar BC = Integer {0}\n".format(slave))
                    fo.write("\tMortar BC Static = Logical True\n")
                    fo.write("\tAnti Radial Projector = Logical True\n")
                    fo.write("\tGalerkin Projector = Logical True\n")
                    fo.write("End\n\n")
            elif k == "MASTER_ROTOR_BOUNDARY":
                for k1, v1 in boundaries.items():
                    if k1 == "SLAVE_ROTOR_BOUNDARY":
                        slave = v1
                        break
                if not self.is_periodicity_a:
                    fo.write("Boundary Condition {0}\n".format(v))
                    fo.write("\tName = {0}\n".format(k))
                    fo.write("\tMortar BC = Integer {0}\n".format(slave))
                    fo.write("\tMortar BC Static = Logical True\n")
                    fo.write("\tRadial Projector = Logical True\n")
                    fo.write("\tGalerkin Projector = Logical True\n")
                    fo.write("End\n\n")
                else:
                    fo.write("Boundary Condition {0}\n".format(v))
                    fo.write("\tName = {0}\n".format(k))
                    fo.write("\tMortar BC = Integer {0}\n".format(slave))
                    fo.write("\tMortar BC Static = Logical True\n")
                    fo.write("\tAnti Radial Projector = Logical True\n")
                    fo.write("\tGalerkin Projector = Logical True\n")
                    fo.write("End\n\n")
            elif k == "SB_STATOR_BOUNDARY":
                for k1, v1 in boundaries.items():
                    if k1 == "SB_ROTOR_BOUNDARY":
                        slave = v1
                        break
                if not self.is_periodicity_a:
                    fo.write("Boundary Condition {0}\n".format(v))
                    fo.write("\tName = {0}\n".format(k))
                    fo.write("\tMortar BC = Integer {0}\n".format(slave))
                    fo.write("\tRotational Projector = Logical True\n")
                    fo.write("\tGalerkin Projector = Logical True\n")
                    fo.write("End\n\n")
                else:
                    fo.write("Boundary Condition {0}\n".format(v))
                    fo.write("\tName = {0}\n".format(k))
                    fo.write("\tMortar BC = Integer {0}\n".format(slave))
                    fo.write("\tAnti Rotational Projector = Logical True\n")
                    fo.write("\tGalerkin Projector = Logical True\n")
                    fo.write("End\n\n")
            elif k == "AIRGAP_ARC_BOUNDARY":
                fo.write("Boundary Condition {0}\n".format(v))
                fo.write("\tName = {0}\n".format(k))
                fo.write("\tSave Line = True\n")
                fo.write("End\n\n")
            else:
                fo.write("Boundary Condition {0}\n".format(v))
                fo.write("\tName = {0}\n".format(k))
                fo.write("End\n\n")

    return elmer_sif_file


def _get_wind_props(machine, label):
    label_dict = decode_label(label)
    lam_obj = get_obj_from_label(machine, label_dict=label_dict)
    wind_mat = lam_obj.winding.get_connection_mat(lam_obj.get_Zs())
    Nrad_id = label_dict["R_id"]  # zone radial coordinate
    Ntan_id = label_dict["T_id"]  # zone tangential coordinate
    Zs_id = label_dict["S_id"]  # Zone slot number coordinate
    # Get the phase value in the correct slot zone
    phase_id = get_phase_id(wind_mat, Nrad_id, Ntan_id, Zs_id)
    Ncond = wind_mat[Nrad_id, Ntan_id, Zs_id, phase_id]

    return phase_id, Ncond
